import enum
from _typeshed import Incomplete
from typing import Any, List, Optional, Protocol, Tuple, Union

class Expression(Protocol):
    def as_expression(self) -> str: ...

class FromClause(Protocol):
    def as_from_clause(self) -> str: ...

class SelectorClause(Protocol):
    def as_selector_clause(self) -> str: ...

class Query(Protocol):
    def as_query(self) -> str: ...

class Vector(Protocol):
    def as_vector(self) -> str: ...

class Selector(Protocol):
    def as_selector(self) -> str: ...

class Statement(Protocol):
    def as_statement(self) -> str: ...

class PragmaValue(Protocol):
    def as_pragma_value(self) -> str: ...

class ColumnConstraint(Protocol):
    def as_column_constraint(self) -> str: ...

class JoinConstraint(Protocol):
    def as_join_constraint(self) -> str: ...

class Ordering(Expression, Protocol):
    def is_ascending(self) -> bool: ...

class Select:
    selector: SelectorClause
    from_clause: FromClause
    where_clause: Optional[Expression]
    group_by: Optional[Expression]
    order_by: List[Ordering]
    limit_clause: int
    offset_clause: int
    def as_query(self) -> str: ...
    def as_vector(self) -> str: ...
    def and_where(self, expression: Expression) -> Select: ...
    def as_statement(self) -> str: ...
    def as_expression(self) -> str: ...
    def as_from_clause(self) -> str: ...
    def __init__(self, selector, from_clause, where_clause, group_by, order_by, limit_clause, offset_clause) -> None: ...

class Insert:
    into: Identifier
    rows: List[List[Expression]]
    columns: Optional[List[Identifier]]
    alias: Optional[Identifier]
    returning: Optional[All]
    def as_statement(self) -> str: ...
    def __init__(self, into, rows, columns, alias, returning) -> None: ...

class Pragma:
    name: str
    schema: Optional[str]
    value: Optional[PragmaValue]
    def as_statement(self) -> str: ...
    def __init__(self, name, schema, value) -> None: ...

class CreateTable:
    name: Identifier
    columns: List[ColumnDefinition]
    if_not_exists: bool
    def as_statement(self) -> str: ...
    def __init__(self, name, columns, if_not_exists) -> None: ...

class CreateIndex:
    name: Identifier
    on: Identifier
    indices: List[IndexDefinition]
    if_not_exists: bool
    def as_statement(self) -> str: ...
    def __init__(self, name, on, indices, if_not_exists) -> None: ...

class Delete:
    table: Identifier
    where: Optional[Expression]
    def as_statement(self) -> str: ...
    def __init__(self, table, where) -> None: ...

class IndexDefinition:
    column: Expression
    descending: bool
    def __init__(self, column, descending) -> None: ...

class ColumnDefinition:
    name: Identifier
    column_type: ColumnType
    constraints: Optional[List[ColumnConstraint]]
    def __init__(self, name, column_type, constraints) -> None: ...

class ColumnType(enum.Enum):
    NULL: str
    INTEGER: str
    REAL: str
    TEXT: str
    BLOB: str
    def as_type_def(self) -> str: ...

class PrimaryKey:
    autoincrement: bool
    def as_column_constraint(self) -> str: ...
    def __init__(self, autoincrement) -> None: ...

class Function:
    name: str
    operands: List[Expression]
    def as_expression(self) -> str: ...
    def __init__(self, name, operands) -> None: ...

class BinaryOp:
    operator: str
    x: Expression
    y: Expression
    def as_expression(self) -> str: ...
    def as_selector(self) -> str: ...
    def __init__(self, operator, x, y) -> None: ...

class Literal:
    value: Any
    def as_expression(self) -> str: ...
    def as_selector(self) -> str: ...
    def as_pragma_value(self) -> str: ...
    def __init__(self, value) -> None: ...

class Identifier:
    names: Union[str, List[str]]
    def as_expression(self) -> str: ...
    def as_from_clause(self) -> str: ...
    def as_selector(self) -> str: ...
    @staticmethod
    def escape(value: str) -> str: ...
    def __init__(self, names) -> None: ...

class ExpressionList:
    expressions: List[Expression]
    def as_expression(self) -> str: ...
    def __init__(self, expressions) -> None: ...

class Null:
    def as_expression(self) -> str: ...
    def as_pragma_value(self) -> str: ...

null: Incomplete

class Alias:
    expression: Expression
    name: Identifier
    def as_from_clause(self) -> str: ...
    def as_selector(self) -> str: ...
    def as_selector_clause(self) -> str: ...
    def __init__(self, expression, name) -> None: ...

class SelectorList:
    selectors: List[Selector]
    def as_selector_clause(self) -> str: ...
    def __init__(self, selectors) -> None: ...

class All:
    def as_selector(self) -> str: ...
    def as_selector_clause(self) -> str: ...

class Aggregate:
    name: str
    expression: Union[Expression, All]
    is_distinct: bool
    def as_selector(self) -> str: ...
    def as_expression(self) -> str: ...
    def __init__(self, name, expression, is_distinct) -> None: ...

class JoinSpec:
    operator: str
    table: Identifier
    constraint: JoinConstraint
    def __init__(self, operator, table, constraint) -> None: ...

def left(table: Identifier, constraint: JoinConstraint) -> JoinSpec: ...
def inner(table: Identifier, constraint: JoinConstraint) -> JoinSpec: ...
def right(table: Identifier, constraint: JoinConstraint) -> JoinSpec: ...

class On:
    expression: Expression
    def as_join_constraint(self) -> str: ...
    def __init__(self, expression) -> None: ...

class Join:
    table: Identifier
    spec: List[JoinSpec]
    def as_from_clause(self) -> str: ...
    def __init__(self, table, spec) -> None: ...

class If:
    condition: Expression
    consequence: Expression
    alternative: Expression
    def as_expression(self) -> str: ...
    def __init__(self, condition, consequence, alternative) -> None: ...

class Case:
    cases: List[Tuple[Expression, Expression]]
    alternative: Optional[Expression]
    def as_expression(self) -> str: ...
    def __init__(self, cases, alternative) -> None: ...

class Asc:
    expression: Expression
    def as_expression(self) -> str: ...
    def is_ascending(self) -> bool: ...
    def __init__(self, expression) -> None: ...

class Desc:
    expression: Expression
    def as_expression(self) -> str: ...
    def is_ascending(self) -> bool: ...
    def __init__(self, expression) -> None: ...
