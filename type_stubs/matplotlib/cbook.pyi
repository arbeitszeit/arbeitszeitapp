import collections.abc
from collections.abc import Generator

from _typeshed import Incomplete

class _StrongRef:
    def __init__(self, obj) -> None: ...
    def __call__(self): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class CallbackRegistry:
    exception_handler: Incomplete
    callbacks: Incomplete
    def __init__(
        self, exception_handler=..., *, signals: Incomplete | None = None
    ) -> None: ...
    def connect(self, signal, func): ...
    def disconnect(self, cid) -> None: ...
    def process(self, s, *args, **kwargs) -> None: ...
    def blocked(
        self, *, signal: Incomplete | None = None
    ) -> Generator[None, None, None]: ...

class silent_list(list):
    type: Incomplete
    def __init__(self, type, seq: Incomplete | None = None) -> None: ...

def strip_math(s): ...
def is_writable_file_like(obj): ...
def file_requires_unicode(x): ...
def to_filehandle(
    fname,
    flag: str = "r",
    return_opened: bool = False,
    encoding: Incomplete | None = None,
): ...
def open_file_cm(path_or_file, mode: str = "r", encoding: Incomplete | None = None): ...
def is_scalar_or_string(val): ...
def get_sample_data(fname, asfileobj: bool = True, *, np_load: bool = True): ...
def flatten(seq, scalarp=...) -> Generator[Incomplete, Incomplete, None]: ...

class Stack:
    def __init__(self, default: Incomplete | None = None) -> None: ...
    def __call__(self): ...
    def __len__(self) -> int: ...
    def __getitem__(self, ind): ...
    def forward(self): ...
    def back(self): ...
    def push(self, o): ...
    def home(self): ...
    def empty(self): ...
    def clear(self) -> None: ...
    def bubble(self, o): ...
    def remove(self, o) -> None: ...

class _Stack:
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def __call__(self): ...
    def __len__(self) -> int: ...
    def __getitem__(self, ind): ...
    def forward(self): ...
    def back(self): ...
    def push(self, o): ...
    def home(self): ...

def safe_masked_invalid(x, copy: bool = False): ...
def print_cycles(objects, outstream=..., show_progress: bool = False) -> None: ...

class Grouper:
    def __init__(self, init=()) -> None: ...
    def __contains__(self, item) -> bool: ...
    def clean(self) -> None: ...
    def join(self, a, *args) -> None: ...
    def joined(self, a, b): ...
    def remove(self, a) -> None: ...
    def __iter__(self): ...
    def get_siblings(self, a): ...

class GrouperView:
    def __init__(self, grouper) -> None: ...
    def __contains__(self, item) -> bool: ...
    def __iter__(self): ...
    def joined(self, a, b): ...
    def get_siblings(self, a): ...

def simple_linear_interpolation(a, steps): ...
def delete_masked_points(*args): ...
def boxplot_stats(
    X,
    whis: float = 1.5,
    bootstrap: Incomplete | None = None,
    labels: Incomplete | None = None,
    autorange: bool = False,
): ...

ls_mapper: Incomplete
ls_mapper_r: Incomplete

def contiguous_regions(mask): ...
def is_math_text(s): ...
def violin_stats(X, method, points: int = 100, quantiles: Incomplete | None = None): ...
def pts_to_prestep(x, *args): ...
def pts_to_poststep(x, *args): ...
def pts_to_midstep(x, *args): ...

STEP_LOOKUP_MAP: Incomplete

def index_of(y): ...
def safe_first_element(obj): ...
def sanitize_sequence(data): ...
def normalize_kwargs(kw, alias_mapping: Incomplete | None = None): ...

class _OrderedSet(collections.abc.MutableSet):
    def __init__(self) -> None: ...
    def __contains__(self, key) -> bool: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def add(self, key) -> None: ...
    def discard(self, key) -> None: ...
