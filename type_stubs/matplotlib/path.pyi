from collections.abc import Generator

from _typeshed import Incomplete

from .bezier import BezierSegment as BezierSegment
from .cbook import simple_linear_interpolation as simple_linear_interpolation

class Path:
    code_type: Incomplete
    STOP: Incomplete
    MOVETO: Incomplete
    LINETO: Incomplete
    CURVE3: Incomplete
    CURVE4: Incomplete
    CLOSEPOLY: Incomplete
    NUM_VERTICES_FOR_CODE: Incomplete
    def __init__(
        self,
        vertices,
        codes: Incomplete | None = None,
        _interpolation_steps: int = 1,
        closed: bool = False,
        readonly: bool = False,
    ) -> None: ...
    @property
    def vertices(self): ...
    @vertices.setter
    def vertices(self, vertices) -> None: ...
    @property
    def codes(self): ...
    @codes.setter
    def codes(self, codes) -> None: ...
    @property
    def simplify_threshold(self): ...
    @simplify_threshold.setter
    def simplify_threshold(self, threshold) -> None: ...
    @property
    def should_simplify(self): ...
    @should_simplify.setter
    def should_simplify(self, should_simplify) -> None: ...
    @property
    def readonly(self): ...
    def copy(self): ...
    def __deepcopy__(self, memo: Incomplete | None = None): ...
    deepcopy = __deepcopy__
    @classmethod
    def make_compound_path_from_polys(cls, XY): ...
    @classmethod
    def make_compound_path(cls, *args): ...
    def __len__(self) -> int: ...
    def iter_segments(
        self,
        transform: Incomplete | None = None,
        remove_nans: bool = True,
        clip: Incomplete | None = None,
        snap: bool = False,
        stroke_width: float = 1.0,
        simplify: Incomplete | None = None,
        curves: bool = True,
        sketch: Incomplete | None = None,
    ) -> Generator[Incomplete, None, None]: ...
    def iter_bezier(self, **kwargs) -> Generator[Incomplete, None, None]: ...
    def cleaned(
        self,
        transform: Incomplete | None = None,
        remove_nans: bool = False,
        clip: Incomplete | None = None,
        *,
        simplify: bool = False,
        curves: bool = False,
        stroke_width: float = 1.0,
        snap: bool = False,
        sketch: Incomplete | None = None,
    ): ...
    def transformed(self, transform): ...
    def contains_point(
        self, point, transform: Incomplete | None = None, radius: float = 0.0
    ): ...
    def contains_points(
        self, points, transform: Incomplete | None = None, radius: float = 0.0
    ): ...
    def contains_path(self, path, transform: Incomplete | None = None): ...
    def get_extents(self, transform: Incomplete | None = None, **kwargs): ...
    def intersects_path(self, other, filled: bool = True): ...
    def intersects_bbox(self, bbox, filled: bool = True): ...
    def interpolated(self, steps): ...
    def to_polygons(
        self,
        transform: Incomplete | None = None,
        width: int = 0,
        height: int = 0,
        closed_only: bool = True,
    ): ...
    @classmethod
    def unit_rectangle(cls): ...
    @classmethod
    def unit_regular_polygon(cls, numVertices): ...
    @classmethod
    def unit_regular_star(cls, numVertices, innerCircle: float = 0.5): ...
    @classmethod
    def unit_regular_asterisk(cls, numVertices): ...
    @classmethod
    def unit_circle(cls): ...
    @classmethod
    def circle(cls, center=(0.0, 0.0), radius: float = 1.0, readonly: bool = False): ...
    @classmethod
    def unit_circle_righthalf(cls): ...
    @classmethod
    def arc(
        cls, theta1, theta2, n: Incomplete | None = None, is_wedge: bool = False
    ): ...
    @classmethod
    def wedge(cls, theta1, theta2, n: Incomplete | None = None): ...
    @staticmethod
    def hatch(hatchpattern, density: int = 6): ...
    def clip_to_bbox(self, bbox, inside: bool = True): ...

def get_path_collection_extents(
    master_transform, paths, transforms, offsets, offset_transform
): ...
